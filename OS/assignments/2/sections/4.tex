\documentclass[]{article}
\usepackage{hyperref}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{caption}
\usepackage{algpseudocodex}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{subfiles}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{xepersian}
\settextfont{XB Niloofar}

\begin{document}
ﺑﻪ ﭘﺮﺳﺶ ﻫﺎﯼ ﺯﯾﺮ ﺑﺎ ﺫﮐﺮ ﺗﻤﺎﻡ ﺟﺰﺋﯿﺎﺕ ﺧﻮﺍﺳﺘﻪ ﺷﺪﻩ ﭘﺎﺳﺦ ﮐﺎﻣﻞ ﺑﺪﻫﯿﺪ.
\begin{enumerate}[(A)]
      \item ﺳﯿﺴﺘﻢ ﻋﺎﻣﻠﯽ ﺭﺍ ﻓﺮﺽ ﮐﻨﯿﺪ ﮐﻪ ﺩﺭ ﺁﻥ ﺗﻨﻬﺎ ﯾﮏ ﻓﺮﺁﯾﻨﺪ ﺩﺭ ﮐﺮﻧﻞ ﻭﻇﯿﻔﻪ ﯼ ﻧﻈﺎﺭﺕ ﺑﺮ ﺍﻣﻨﯿﺖ ﻭ ﺻﺤﺖ ﺍﺟﺮﺍﯼ ﻧﺦ ﻫﺎﯼ ﺳﻄﺢ ﮐﺮﻧﻞ ﺭﺍ ﺑﺮ
            ﻋﻬﺪﻩ ﺩﺍﺭﺩ. ﺣﺎﻝ ﻓﺮﺽ ﮐﻨﯿﺪ ﺩﺭ ﮐﻨﺎﺭ ﭼﻨﺪ ﻧﺦ ﺩﯾﮕﺮ ﮐﻪ ﺍﺯ ﭘﯿﺶ ﺩﺭ ﺍﯾﻦ ﺳﯿﺴﺘﻢ ﻣﻮﺟﻮﺩ ﺑﻮﺩﻧﺪ، ﯾﮏ ﻧﺦ ﺟﺪﯾﺪ ﺍﯾﺠﺎﺩ ﻣﯽ ﺷﻮﺩ ﻭ ﮐﺮﻧﻞ ﺑﺮﺍﯼ
            ﺳﺎﺧﺖ ﻧﺦ ﻫﺎ ﺍﺯ ﻣﻌﻤﺎﺭﯼ ﯾﮏ ﺑﻪ ﯾﮏ ﺗﺒﻌﯿﺖ ﻣﯽ ﮐﻨﺪ. ﺍﮐﻨﻮﻥ ﺍﮔﺮ ﻧﺦ ﺟﺪﯾﺪ ﻧﯿﺎﺯ ﺑﻪ ﻓﺮﺍﺧﻮﺍﻧﺪﻥ ﯾﮏ ﻓﺮﺍﺧﻮﺍﻥ ﺳﯿﺴﺘﻤﯽ ﭘﯿﺪﺍ ﮐﻨﺪ ﮐﻪ ﻧﯿﺎﺯ
            ﺍﺳﺖ ﻓﺮﺁﯾﻨﺪ ﻧﻈﺎﺭﺗﯽ ﻧﺎﻡ ﺑﺮﺩﻩ ﺷﺪﻩ ﺩﺭ ﺑﺎﻻ ﺑﺮ ﺭﻭﯼ ﺁﻥ ﻧﻈﺎﺭﺕ ﮐﻨﺪ، ﺑﻪ ﭘﺮﺳﺶ ﻫﺎﯼ ﮐﺎﺭ ﭘﺎﺳﺦ ﺩﻫﯿﺪ:
            \begin{enumerate}[i.]
                  \item ﺳﯿﺴﺘﻢ ﺑﺮﺍﯼ ﻧﻈﺎﺭﺕ ﺑﺮ ﻧﺦ ﺟﺪﯾﺪ ﺑﺎﯾﺪ ﺑﻪ ﭼﻪ ﺷﮑﻞ ﻋﻤﻞ ﮐﻨﺪ؟
                        معماری تولید نخ یک‌به‌بک است. این یعنی به ازای هر نخ تولید شده در فضای کاربر، یک نخ متناظر در فضای کرنلی تولید می‌شود.
                        پس فرآیند نظارتی باید بتواند روی تک‌تک نخ‌های کرنل نظارت داشته باشد.
                        برای نظارت داشتن و رصد کردن فراخوان‌های سیستمی باید یک الگو برای مدیریت انتخاب کنیم. سناریو‌های گوناگونی می ‌توان متصور شد.
                        \vspace{-0.25cm}
                        \paragraph*{صد کردن مستقیم \lr{(Direct Monitoring)}}
                        فرآیند نظارتی با استفاده از \lr{system hooks}
                        تمامی فراخوانی‌های سیستمی از جانب نخ‌های کرنل را رصد می‌کند. باید ساختار هندلر فراخوانی‌های سیستمی را تغییر داد.
                        به گونه‌ای که به فرآیند نظارتی قبل از اینکه روال مناسب را اجرا کند خبر داده شود. تا بعد از تایید این فرآیند نظارتی اجرای روال صورت گیرد.
                        \\
                        \textbf{مزیت : } تاخیر ندارد و به صورت \lr{Real-Time} رصد کردن را در اختیار دارد.
                        \\
                        \textbf{عیب : } سربار زیاد به دلیل اینکه هر فراخوان سیتمی نیاز به دخالت این فرآیند نظارتی را می‌طلبد.
                        \vspace{-0.25cm}
                        \paragraph*{مکانیزم اعلان \lr{(Notification Mechanism)}}
                        در این روش، وظیفه‌ی باخبر کردن فرآیند نظارتی، هنگام رخ دادن فراخوان سیستمی را به کرنل واگذار می‌کنیم.
                        ر این روشی بعضی از فرآیند‌ّا به خود کرنل واگذار می‌شوند.
                        یعنی یک رصد اولیه انجام بدهد و اگر پتانسیل وجود یک خطر امنیتی را حس کرد به فرآیند نظارتی اعلان بفرستد.
                        \\
                        \textbf{مزیت : } کرنل برای فرآیند‌های مربوط به فرآیند نظارتی آن را باخبر می‌کند. در نتیجه سربار کمتری برای فرآیند نظارتی داریم.
                        \\
                        \textbf{عیب : }  تاخیر به دلیل این که سیستم اعلان، پتانسیل تأخیر را داراست.
                        \vspace{-0.25cm}
                        \paragraph*{استفاده از صف \lr{(Queue-Based Monitoring)}}
                        فراخوان‌های سیستمی که نیاز به نظارت دارند به ترتیب در یک صف نگهداری می‌شوند.
                        پیاده‌ سازی آن میتواند از طریق یک صف اشتراکی بین کرنل و فرآیند نظارتی صورت گیرد.
                        \\
                        \textbf{مزایا : }
                        \begin{itemize}
                              \renewcommand\labelitemi{-}
                              \item رصد کردن را ساده‌تر می‌کند و پیچیدگی روش‌های قبل را ندارد.
                              \item اجازه می‌دهد که فرآیند نظارتی با سرعت خودش این فراخوان‌های سیستمی را مدیریت کند.
                        \end{itemize}
                        \textbf{عیب : } استفاده از صف نیاز به همگام‌سازی دارد وکرنه باعث وضعیت رقابتی می‌شود.
                  \item ﺍﯾﻦ ﺳﺎﺯﻭﮐﺎﺭ ﭼﻪ ﺗﺎﺛﯿﺮﯼ ﺑﺮ ﭼﻨﺪﻭﻇﯿﻔﮕﯽ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﺧﻮﺍﻫﺪ ﮔﺬﺍﺷﺖ؟
                        \begin{itemize}
                              \renewcommand\labelitemi{-}
                              \item منطقا یک سربار اضافه میشود. چون باید نخ‌های اجرایی پیوسته رصد شوند.
                              \item فرآیند نظارتی، یک منبع است. فراخوان‌های سیستمی باید از دروازه‌ی این فرآنید رد شوند. همین رقابت بر سر منبع نیز میتواند یک نقطه‌ ضعف باشد.
                              \item برای جلوگیری از بن‌بست‌ها \lr{(Deadlocks)} و شرایط رقابتی \lr{(Race Conditions)} برای وقتی که با استفاده از صف، فرآیند نظارتی را پیاده‌سازی میکنیم، باید بتوانیم همگام‌سازی لازم را صورت بدهیم.
                              \item  یک مقوله‌ برای مدیریت به سیستم کامپیوتری اضافه شده است. همین موضوع  مقیاس‌پذیری سیستم کامپیوتری را کاهش می‌دهد.
                        \end{itemize}
                  \item ﺭﺍﻫﮑﺎﺭ ﺷﻤﺎ ﺑﺮﺍﯼ ﺣﻞ ﻣﺸﮑﻼﺕ ﺑﻪ ﻭﺟﻮﺩ ﺁﻣﺪﻩ ﭼﯿﺴﺖ؟
                        \begin{itemize}
                              \renewcommand\labelitemi{-}
                              \item به جای بررسی کردن هر فراخوان سیستمی، اطلاعات که مربوط به نخ را کش کنیم و برای بررسی‌های آتی آن‌ها را ملاک قرار بدهیم.
                              \item شدت رصد کردن را تغییر بدهیم. یک سامانه‌ی اولویتی به فراخوان‌های سیستمی بدهیم تا فقط آن دسته از فراخوان‌های سیستمی که احتمال خطای امنیتی زیادی دارند،
                                    تماما رصد شوند و این رصد برای بقیه‌ی فرآیند‌ها، با احتمال خطای امنیتی کمتر، کمتر باشد و یا کلاً نباشد(یعنی فرآیند را امن تشخیص دهیم).
                              \item از موازی سازی استفاده کنیم. به گونه‌ای که برای رصد کردن، اجرای نخ‌ها متوقف نشود. و اجرای فرآیند نظارتی در پیش‌زمینه صورت بگیرد.
                        \end{itemize}
            \end{enumerate}
      \item  ﻓﺮﺽ ﮐﻨﯿﺪ ﺩﺍﺩﻩ ﺍﯼ ﺩﺭ ﯾﮏ ﺑﺨﺶ ﺍﺯ ﺣﺎﻓﻈﻪ
            (ﯾﮏ ﻓﺎﯾﻞ)
            ﻭﺟﻮﺩ ﺩﺍﺭﺩ ﻭ ﭼﻨﺪ ﻓﺮﺁﯾﻨﺪ ﻧﯿﺎﺯ ﺑﻪ ﺩﺳﺘﺮﺳﯽ ﺩﻗﯿﻘﺎ ﻫﻤﺰﻣﺎﻥ ﺑﻪ ﺁﻥ ﺩﺍﺭﻧﺪ، ﻫﻤﭽﻨﯿﻦ
            ﻫﻤﭽﻨﯿﻦ ﻓﺮﺽ ﮐﻨﯿﺪ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﻫﯿﭻ ﺗﻀﻤﯿﻨﯽ ﺑﺮ ﺭﻭﯼ ﮐﻨﺘﺮﻝ ﺩﺳﺘﺮﺳﯽ ﻫﻤﺰﻣﺎﻥ ﻭ ﻋﺪﻡ ﺧﺮﺍﺑﯽ ﺩﺍﺩﻩ ﻫﺎﯼ ﺍﯾﻦ ﺑﺨﺶ ﺍﺯ ﺣﺎﻓﻈﻪ
            (فایل)
            ﻧﻤﯽ ﺩﻫﺪ.
            ﺳﺎﺯﻭﮐﺎﺭﯼ ﻃﺮﺍﺣﯽ ﮐﻨﯿﺪ ﮐﻪ ﺑﺎ ﺍﺳﺘﻔﺎﺩﻩ ﺍﺯ ﺁﻥ ﺑﺘﻮﺍﻥ ﺑﺮﻧﺎﻣﻪ ﺍﯼ ﻧﻮﺷﺖ ﮐﻪ ﺩﺭ ﭼﻨﯿﻦ ﺳﯿﺴﺘﻤﯽ ﺑﻪ ﻫﻨﮕﺎﻡ ﻧﯿﺎﺯ ﺑﻪ ﺩﺳﺘﺮﺳﯽ ﺑﻪ ﯾﮏ ﺣﺎﻓﻈﻪ
            (فایل)
            ﻫﯿﺞ ﺧﺮﺍﺑﯽ ﺭﺥ ﻧﺪﻫﺪ
            (ﺍﻣﮑﺎﻥ ﺍﺳﺘﻔﺎﺩﻩ ﺍﺯ ﺗﺎﺑﻊ \text{print()} ﻭ ﻫﻤﭽﻨﯿﻦ ﺳﺎﺧﺘﺎﺭﻫﺎﯼ mutex ﻭ ﺳﻤﺎﻓﻮﺭ ﺭﺍ ﻧﺨﻮﺍﻫﯿﺪ ﺩﺍﺷﺖ)
            \\
            سیستم عامل هیچ تضمینی برای مدیریت و هماهنگی فایل‌ها به ما نمی‌دهد و از ابزار‌های mutex و semaphore  بعنوان ابزار‌های نرم‌افزاری شایع برای این کنترل نمیتوانیم استفاده کنیم. از تابع sleep هم نمی‌توان استفاده کرد.
            میتوانیم از فایل‌های قفل‌کننده
            \lr{(Lock Files)}
            استفاده کنیم. فرآیند‌ها برای دسترسی به حافظه‌ی اشتراکی ابتدا وجود فایل قفل‌کننده‌ی مربوطه به آن حافظه‌ی اشتراکی را بررسی میکنند. این فایل به عنوان نشانگر یک قفل عمل میکند.
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item اگر فایل قفل‌کننده وجود داشته باشد، فرآیند صبر می‌کند تا قفل آزاد شود.
                        در مدتی که فرآیند صبر می‌کند تا فایل قفل آزاد شود، باید در
                        \lr{busy waiting}
                        بماند که بهینه نیست.
                  \item  اگر فایل قفل‌کننده وجود نداشته باشد، فرآیند فایل قفل‌کننده را ایجاد می‌کند.
                        \begin{itemize}
                              \item  در ایجاد این قفل باید از یک عملیات *اتمیک* استفاده کنیم.
                              \item اتمیک بودن سبب می‌شود تا هنگامی که چند فرآیند بخواهند همزمان یک فایل قفل ایجاد کنند فقط یکی از آنان موفق بشود.
                              \item مثل تابع open با فلگ
                                    \lr{O\_CREATE | O\_EXCL} در سیستم‌های POSIX
                              \item یا با \lr{directory creation}  که در بیشتر فایل سیستم‌ها اتمیک است.
                        \end{itemize}
                  \item پس از ایجاد حافظه، فرآیند می‌تواند عملیات مورد نظرش را (خواندن یا نوشتن) در حافظه‌ی اشتراکی پیاده‌ کند.
                  \item پس از اتمام کار فرآیند فایل قفل‌کننده را حذف می‌کند تا بقیه‌ی فرآیند‌ها هم بتوانند به آن حافظه‌ی اشتراکی دسترسی پیدا کنند.
            \end{itemize}

      \item {ﺩﺭ ﻣﺪﻝ ﺗﺒﺎﺩﻝ ﭘﯿﺎﻡ ﺑﺎ ﺗﻮﺟﻪ ﺑﻪ ﺍﯾﻨﮑﻪ ﺣﺎﻓﻈﻪ ﺑﺮﺍﯼ ﻧﮕﻬﺪﺍﺭﯼ ﭘﯿﺎﻡ ﻣﺤﺪﻭﺩ ﺍﺳﺖ، ﺳﺎﺯﻭﮐﺎﺭﯼ ﺍﺭﺍﺋﻪ ﺩﻫﯿﺪ ﮐﻪ ﺑﺘﻮﺍﻧﯿﻢ
            (با تقریب خوبی)
            ﺗﻌﺪﺍﺩ ﻧﺎﻣﺤﺪﻭﺩﯼ ﭘﯿﺎﻡ ﺩﺭ ﺻﻨﺪﻭﻕ ﭘﯿﺎﻡ ﺑﻔﺮﺳﺘﯿﻢ.}
            میتوانیم از مفهوم بافر نامحدود بهره ببریم. این بافر پیاده‌سازی‌های گوناگونی دارد.
            از جمله پیاده‌سازی با لیست پیوندی یا با لیست‌های داینامیک. در تئوری می‌توانیم تا بی‌نهایت در این بافر پیام درج کنیم. اما نکته‌ی مهم اینست که در عمل حافظه‌ محدودیت دارد.
            لیست پیوندی تا بینهایت پیش نمی‌رود. برای همین میگوییم با تقریب خوبی این حافظه نامحدود است.
            \\
            ایده‌ی دیگر برای بهبود حافظه اینست که در این پیاده‌سازی یک بیشینه حافظه تعریف کنیم و پس از اینکه بافر پر شد با یک سیاست مشخص شروع به جایگزینی یک پیام انتخابی با پیام جدید کنیم.
            مثلا سیاست انتخابی می‌تواند این باشد: پیامی که از همه زودتر به بافر اضافه شده است از همه زودتر هم خارج شود(مانند یک صف سیاست FIFO داشته باشد).
            میتوانیم از یک صف حلقوی (یا لیست پیوندی حلقوی) برای این پیاده‌سازی استفاده کنیم.
            راه‌های زیادی برای این پیاده‌سازی پیش روی ماست.
            \\
            هر کدام ممکن است نکات مثبت و منفی گوناگونی داشته یاشند. مثلا یک پیاده‌سازی ممکن است سرعت دسترسی به پیام بیشتری داشته باشد و در ازای آن مجبور به حذف پیام‌های بیشتری شود.
            \\
            حتی میتوانیم یک قدم جلوتر برویم و از یک حافظه‌ی جانبی (مانند swap در فرآیند‌ها) برای افزایش گنجایش بافر استفاده کنیم.
            این فیچر پیچیدگی را منطقا زیاد می‌کند اما در تئوری با این روش می‌تونیم پیام‌های بیشتری را به صورت همزمان ذخیره کنیم.

      \item ﺷﺮﺍﯾﻄﯽ ﺭﺍ ﺑﯿﺎﻥ ﮐﻨﯿﺪ ﮐﻪ ﺩﺭ ﺁﻥ ﻣﻮﺍﺯﯼ ﺳﺎﺯﯼ ﺑﻪ ﻫﯿﭻ ﻭﺟﻪ ﻧﻤﯽ ﺗﻮﺍﻧﺪ ﺑﻪ ﺗﺴﺮﯾﻊ ﻣﺤﺎﺳﺒﺎﺕ ﮐﻤﮏ ﮐﻨﺪ.
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item فرض کنید که میخواهید یک فرآیند بسیار سبک را اجرا کنید. در این حالت سربار اجرای موازی آن از سودی که دارد بیشتر می‌شود.
                  \item فرض کنید چند تسک که میخواهید اجرا کنید به هم وابستگی زیادی داشته باشند.
                        این شرایط باعث محدودیت در اجرای موازی میشود. و مانند مورد بالا در نهایت ممکن است سربار آن بسیار بالا برود.
                  \item الگوریتم‌هایی وجود دارند که مانند یک دنباله و به هم متصل اجرا می‌شوند.
                        در این الگوریتم‌ اجرای موازی و شکستن فرآیند به چند تسک ممکن نیست.
            \end{itemize}
      \item ﺗﺤﻘﯿﻖ ﮐﻨﯿﺪ ﮐﻪ ﺩﺭ ﮐﺪﺍﻡ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﻫﺎ ﻣﺪﻝ ﻫﺎﯼ ﭼﻨﺪﻧﺨﯽ ﺩﻭ ﺳﻄﺤﯽ ﻭ ﭼﻨﺪ ﺑﻪ ﭼﻨﺪ ﭘﯿﺎﺩﻩ ﺳﺎﺯﯼ ﺷﺪﻩ ﺍﺳﺖ ﻭ ﻫﻤﭽﻨﯿﻦ ﺁﯾﺎ ﻫﻨﻮﺯ
            ﺍﺳﺘﻔﺎﺩﻩ ﺍﯼ ﺍﺯ ﺍﯾﻦ ﻣﺪﻝ ﻫﺎ ﺻﻮﺭﺕ ﻣﯽ ﮔﯿﺮﺩ ﯾﺎ ﺧﺒﺮ؟ ﻋﻠﺖ ﺁﻥ ﺭﺍ ﻧﯿﺰ ﺑﯿﺎﻥ ﮐﻨﯿﺪ.
            \vspace{-0.4cm}
            \paragraph*{مدل چند به چند \lr{(Many-to-Many)}}
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item این مدل در برخی نسخه‌های قدیمی‌تر از Solaris
                        (مانند \lr{Solaris 2.x})
                        و IRIX پیاده‌سازی شده است.
                  \item در برخی از سیستم‌های قدیمی‌تر یونیکس از این مدل استفاده می‌شد.
                  \item این مدل به تدریج کنار گذاشته شد و امروز به ندرت از آن استفاده می‌شود
            \end{itemize}
            \vspace{-0.4cm}
            \paragraph*{مدل دو سطحی \lr{(Two-Level)}}
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item در نسخه‌های قدیمی‌تر FreeBSD از این مدل استفاده میشد.
                  \item امروزه به ندرت استفاده می‌شود.
            \end{itemize}
            \paragraph*{چرا این مدل‌ها دیگر رایج نیستند ؟}
            \begin{enumerate}[1.]
                  \item پیچیدگی مدیریت:
                        نگاشت نخ‌های کاربر به نخ‌های هسته نیازمند الگوریتم‌های پیچیده است که می‌تواند مشکلاتی مانند گرسنگی منابع
                        \lr{(Resource Starvation)}
                        ایجاد کند.
                  \item بهبود سخت‌افزار:
                        پردازنده‌های چند هسته‌ای مدرن و معماری‌های جدید به مدل‌های ساده‌تر (مانند یک به یک) اجازه می‌دهند به طور کارآمدتری عمل کنند
                  \item بهبود سیستم‌های عامل:
                        هسته سیستم‌عامل‌های مدرن قابلیت مدیریت کارآمد نخ‌ها را در مدل یک به یک فراهم کرده است.
            \end{enumerate}
      \item ﺳﯿﺴﺘﻢ ﻋﺎﻣﻠﯽ ﺭﺍ ﻓﺮﺽ ﮐﻨﯿﺪ ﮐﻪ ﺩﺭ ﺁﻥ ﻫﯿﭻ ﺍﻣﮑﺎﻥ ﺍﺷﺘﺮﺍﮎ ﮔﺬﺍﺭﯼ ﺩﺍﺩﻩ ﺍﯼ ﻣﯿﺎﻥ ﻓﺮﺁﯾﻨﺪ ﻫﺎ ﻭﺟﻮﺩ ﻧﺪﺍﺷﺘﻪ ﺑﺎﺷﺪ. ﺩﺭ ﺍﯾﻦ ﺻﻮﺭﺕ ﺑﮕﻮﯾﯿﺪ
            ﭼﮕﻮﻧﻪ ﻣﯽ ﺗﻮﺍﻥ ﺩﺍﺩﻩ ﺍﯼ ﺭﺍ ﻣﯿﺎﻥ ﭼﻨﺪ ﻓﺮﺁﯾﻨﺪ ﺑﻪ ﺍﺷﺘﺮﺍﮎ ﮔﺬﺍﺷﺖ.
            \\
            اگر نتوان از روش‌های مستقیم برای اشتراک‌گذاری اطلاعات بین فرآیند‌ها استفاده کرد، باید برای انتقال داده از روش‌های غیرمستقیم استفاده کنیم.
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item فایل‌های موقتی در دیسک ذخیره شده باشند و فرآیند‌ها بتوانند از طریق آن با هم داده رد و بدل کنند
                        یا میتوانیم سیستم‌عامل را قاطی این مکانیزم کنیم و بخشی از حافظه‌ی اصلی که به یک فایل مرتبط می‌شود در اختیار فرآیند‌ها قرار بگیرد.
                  \item یا مثلا با استفاده از پایگاه‌های داده‌ این عمل صورت گیرد. فرآیند‌ها اطلاعات را در یک پایگاه داده ذخیره و بازیابی کنند.
            \end{itemize}
      \item ﻓﺮﺽ ﮐﻨﯿﺪ ﺩﺭ ﯾﮏ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﻫﯿﭻ ﺗﻀﻤﯿﻨﯽ ﺑﺮ ﺭﻭﯼ ﻋﺪﻡ ﻫﻢ ﭘﻮﺷﺎﻧﯽ ﺑﺨﺶ ﺩﺍﺩﻩ ﻭ ﻫﺮﻡ ﻧﺒﺎﺷﺪ. ﺳﺎﺯﻭﮐﺎﺭﯼ ﺍﺭﺍﺋﻪ ﮐﻨﯿﺪ ﮐﻪ ﺑﺎ ﺍﺳﺘﻔﺎﺩﻩ
            ﺍﺯ ﺁﻥ ﺩﺭ ﺑﺮﻧﺎﻣﻪ ﯼ ﺧﻮﺩ ﺑﺘﻮﺍﻧﯿﻢ ﺍﺯ ﻫﻤﭙﻮﺷﺎﻧﯽ ﺟﻠﻮﮔﯿﺮﯼ ﮐﻨﯿﻢ.
            \\
            اگر سیستم‌عامل این عدم هم‌پوشانی را مدیریت نمی‌کند، به این معنی است که ما باید به صورت دستی این محدودیت و مرز را مدیریت کنیم.
            اگر مطمین باشیم که حافظه‌ی هرم به صورت کاملا ایزوله از دیگر بلاک‌های حافظه استفاده می‌شود،
            ی‌توانیم مطمین باشیم که با بخش داده نیز هم‌پوشانی و تداخلی ندارد. اول از همه یه بخشی از حافظه را به هرم تخصیص می‌دهیم.
            حال  توابع شخصی‌سازی شده‌ای برای تخصیص حافظه از هرم یا آزاد کردن از هرم بنویسیم. با این اقدامات می توانیم مطمین شویم که هرم هیچ تصرفی در بخش داده نخواهد کرد.
            \begin{itemize}
                  \renewcommand\labelitemi{-}
                  \item  می‌توانیم یک گارد محافظتی  نیز اطراف حافظه‌ی هرم قرار دهیم تا مطمین شویم از بخش داده‌ تصرفی در حافظه‌ی هرم صورت نمی‌گرد.
                        . به این گارد صفحات حافظه‌ای نگهبان
                        \lr{(Memory Guard Pages)}
                        می‌گویند
                  \item تعریف: صفحاتی از حافظه که غیرقابل‌دسترسی‌اند(برای مثال نه می‌توان در آن‌ها نوشت و نه از آن‌ها خواند). اگر برنامه‌ای بخواهد برای ذخیره یا بازیابی به آن‌ها دسترسی بیابد با خطا مواجه خواهد شد
                  \item  می‌توانیم قبل از حافظه‌ی هرم و بعد از آن از این گارد‌های محافظتی استفاده کنیم.
                        به این طریق می‌توانیم مطمین شویم که حافظه‌ی هرم از محدوده‌ی تعیین شده به آن‌طرف‌تر دسترسی نخواهد داشت.
            \end{itemize}
\end{enumerate}
\end{document}