\documentclass[]{article}
\usepackage{hyperref}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{caption}
\usepackage{algpseudocodex}
\usepackage{tabularray}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{subfiles}
\usepackage{xcolor}
\usepackage{enumerate}
\usepackage{xepersian}
\settextfont{XB Niloofar}

\begin{document}
ﭘﺮﺳﺶ ﻫﺎﯼ ﺯﯾﺮ ﺩﺍﺭﺍﯼ ﻧﻤﺮﻩ ﯼ ﺍﺿﺎﻓﯽ ﻫﺴﺘﻨﺪ ﻭ ﭘﺎﺳﺦ ﺑﻪ ﺁﻧﻬﺎ ﺿﺮﻭﺭﯼ ﻧﯿﺴﺖ. ﺩﺭ ﺻﻮﺭﺕ ﺗﻤﺎﯾﻞ ﺑﻪ ﺩﺭﯾﺎﻓﺖ ﻧﻤﺮﻩ ﯼ ﺍﺿﺎﻓﯽ ﺑﻪ ﺁﻧﻬﺎ ﺑﻪ ﺻﻮﺭﺕ
ﮐﺎﻣﻞ ﭘﺎﺳﺦ ﺑﺪﻫﯿﺪ.

\begin{enumerate}[(A)]
    \item ﻓﺮﺽ ﮐﻨﯿﺪ ﺩﺭ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﻓﺮﺍﺧﻮﺍﻧﯽ ﻭﺟﻮﺩ ﺩﺍﺭﺩ ﮐﻪ ﭘﺲ ﺍﺯ ﻓﺮﺍﺧﻮﺍﻧﯽ ﺁﻥ ﺗﻮﺳﻂ ﺑﺮﻧﺎﻣﻪ ﻓﺮﺁﯾﻨﺪ ﺑﺮﺍﯼ ﻣﺪﺗﯽ ﻣﺴﺪﻭﺩ ﺷﺪﻩ ﻭ ﭘﺲ ﺍﺯ ﺁﻣﺎﺩﻩ
    ﺷﺪﻥ ﺩﺍﺩﻩ ﯼ ﻣﻮﺭﺩ ﻧﻈﺮ ﺁﻥ ﺩﺍﺩﻩ ﺗﻮﺳﻂ ﺳﯿﺴﺘﻢ ﻋﺎﻣﻞ ﺑﺎ ﺑﺮﻧﺎﻣﻪ ﺑﻪ ﺍﺷﺘﺮﺍﮎ ﮔﺬﺍﺷﺘﻪ ﻣﯽ ﺷﻮﺩ. ﺩﺭ ﺍﯾﻦ ﺻﻮﺭﺕ ﺑﻪ ﺳﻮﺍﻻﺕ ﺯﯾﺮ ﭘﺎﺳﺦ ﺩﻫﯿﺪ:
        \begin{enumerate}[i.]
            \item ﺍﺯ ﻣﯿﺎﻥ ﺩﻭ ﺷﯿﻮﻩ ﯼ ﺻﻨﺪﻭﻕ ﭘﯿﺎﻡ ﻭ ﺍﺷﺘﺮﺍﮎ ﺣﺎﻓﻈﻪ ﮐﺪﺍﻡ ﺭﻭﺵ ﺑﺮﺍﯼ ﺍﯾﻦ ﻣﻨﻈﻮﺭ ﻣﻨﺎﺳﺐ ﺗﺮ ﺍﺳﺖ؟ ﭘﺎﺳﺦ ﺧﻮﺩ ﺭﺍ ﺗﻮﺟﯿﻪ ﮐﻨﯿﺪ.
            \\
            اگر سیستم‌عامل بخواهد چنین فراخوانی را داشته باشد از آنجایی که میتواند مسدود کردن و سپس ادامه کار را به راحتی انجام دهد،
            استفاده از حافظه اشتراکی گزینه مناسب‌تری است چرا که سرعت بیشتری دارد، پیچیدگی خاصی ندارد و احتیاجی به کپی کردن دیتا در فرآیند نیست.
            سیستم‌عامل پس از اینکه اجرای فرآیند را مسدود کرد، داده را درون حافظه اشتراکی قرار میدهد و آدرس آن را به فرآیند
            می‌دهد و اجرای آن را از سر میگیرد.
            \item ﺍﺳﺘﻔﺎﺩﻩ ﺍﺯ ﺭﻭﺵ ﺩﯾﮕﺮ ﭼﻪ ﻣﻌﺎﯾﺒﯽ ﺧﻮﺍﻫﺪ ﺩﺍﺷﺖ؟
            \\ استفاده از انتقال پیام به دلیل سرباری که روی کرنل به‌دلیل \lr{system call} ها
            دارد نمیتواند گزینه خوبی برای دیتا‌هایی با اندازه زیاد باشد و به دلیل اینکه دیتا باید از صف پیام‌ها
            به حافظه فرآیند منتقل شود تاخیر بیشتری نیز دارد. 
            \item ﺑﻪ ﺟﺰ ﺍﺷﺘﺮﺍﮎ ﭘﯿﺎﻡ ﻭ ﺍﺷﺘﺮﺍﮎ ﮔﺬﺍﺭﯼ ﺣﺎﻓﻈﻪ ﺁﯾﺎ ﺭﻭﺵ ﺑﻬﺘﺮﯼ ﺑﺮﺍﯼ ﺍﻧﺠﺎﻡ ﺍﯾﻦ ﮐﺎﺭ ﺳﺮﺍﻍ ﺩﺍﺭﯾﺪ؟ ﺭﻭﺵ ﺧﻮﺩ ﺭﺍ ﺑﻪ ﺻﻮﺭﺕ ﮐﺎﻣﻞ
            ﺷﺮﺡ ﺩﻫﯿﺪ ﻭ ﺑﮕﻮﯾﯿﺪ ﭼﺮﺍ ﺍﯾﻦ ﺭﻭﺵ ﺍﺯ ﺭﻭﺵ ﻫﺎﯼ ﯾﺎﺩ ﺷﺪﻩ ﺩﺭ ﺑﺎﻻ ﺑﻬﺘﺮ ﺍﺳﺖ.
            \\
            روش دیگری که می‌توان برای این کار استفاده کرد، فایل‌های موقت هستند که بدین صورت که سیستم‌عامل
            یک فایل موقت ایجاد کرده و داده‌ها را در آن ذخیره می‌کند و آدرس آن را به فرآیند برمی‌گرداند.
            در این روش فرآیند می‌تواند از این فایل بخواند، در آن بنویسد و یا حتی آن را ذخیره کنید تا
            بعدا از این فایل دوباره استفاده کند. این کار پیچیدگی کمتری از دو روش بالا دارد و سرعت آن نیز مناسب خواهد بود.
        \end{enumerate}
    \item  ﺷﻤﺎ ﯾﮏ ﺑﺮﻧﺎﻣﻪ ﭼﻨﺪ ﻧﺨﯽ ﺑﺮﺍﯼ ﭘﺮﺩﺍﺯﺵ ﺩﺍﺩﻩ ﻫﺎﯼ ﻭﺭﻭﺩﯼ ﻃﺮﺍﺣﯽ ﮐﺮﺩﻩ ﺍﯾﺪ ﮐﻪ ﺍﺯ ﺳﻪ ﻧﺦ ﻣﺨﺘﻠﻒ ﺑﺮﺍﯼ ﭘﺮﺩﺍﺯﺵ ﺩﺍﺩﻩ ﻫﺎ ﺍﺳﺘﻔﺎﺩﻩ ﻣﯽ ﮐﻨﺪ.
    ﻧﺦ ﺍﻭﻝ ﺑﺎﯾﺪ ﺩﺍﺩﻩ ﻫﺎ ﺭﺍ ﺍﺯ ﻓﺎﯾﻞ ﻫﺎ ﺑﺨﻮﺍﻧﺪ، ﻧﺦ ﺩﻭﻡ ﺩﺍﺩﻩ ﻫﺎ ﺭﺍ ﭘﺮﺩﺍﺯﺵ ﮐﺮﺩﻩ ﻭ ﻧﺦ ﺳﻮﻡ ﻧﺘﺎﯾﺞ ﺭﺍ ﺫﺧﯿﺮﻩ ﮐﻨﺪ. ﭘﺲ ﺍﺯ ﺍﺟﺮﺍ، ﻣﺘﻮﺟﻪ ﻣﯽ ﺷﻮﯾﺪ
    ﮐﻪ ﺳﺮﻋﺖ ﭘﺮﺩﺍﺯﺵ ﮐﻨﺪﺗﺮ ﺍﺯ ﺣﺪ ﺍﻧﺘﻈﺎﺭ ﺍﺳﺖ ﻭ ﺑﺮﺧﯽ ﻧﺦ ﻫﺎ ﺑﻪ ﻃﻮﺭ ﻏﯿﺮﺿﺮﻭﺭﯼ ﻣﻨﺘﻈﺮ ﻧﺦ ﻫﺎﯼ ﺩﯾﮕﺮ ﻣﯽ ﻣﺎﻧﻨﺪ.
        \begin{enumerate}
            \item ﻣﺸﮑﻞ ﺍﺻﻠﯽ ﺩﺭ ﻧﺤﻮﻩ ﺯﻣﺎﻥ ﺑﻨﺪﯼ ﻧﺦ ﻫﺎ ﭼﯿﺴﺖ؟
            \\
            مشکلی اصلی در این است که زمانبندی نخ‌ها به صورتی است که وقتی داده خوانده نشده است،
            CPU به نخ پردازشی اختصاص داده میشود درحالی که چیزی برای پردازش وجود ندارد
            یا به نخ ذخیره سازی اختصاص داده میشود درحالی که چیزی برای ذخیره سازی وجود ندارد
            پس مدت زمانی را که میتوانست به نخی اختصای یابد که میتواند کار مفیدی انجام دهد به نخی اختصاص می‌یابد که
            باید منتظر بماند.

            \item ﭼﮕﻮﻧﻪ ﺯﻣﺎﻥ ﺑﻨﺪﯼ ﻣﻨﺎﺳﺐ ﻧﺦ ﻫﺎ ﻣﯽ ﺗﻮﺍﻧﺪ ﺑﻪ ﺑﻬﺒﻮﺩ ﻋﻤﻠﮑﺮﺩ ﺑﺮﻧﺎﻣﻪ ﮐﻤﮏ ﮐﻨﺪ؟
            \\
            اگر زمانبدی نخ‌ها به درستی انجام شود، نتیجه پردازش‌ها به صورت جریانی از داده‌ها
            ذخیره می‌شود و احتیاجی نیست که کاربر منتظر پایان تمام برنامه باشد تا از نتایج استفاده کند
            ولی این اتفاق نیازمند زمان‌بندی درست اجرای نخ‌ها است تا زمان کلی اجرای برنامه بیشتر از چیزی که باید نشود
            چرا که این موضوع باعث هدر رفتن وقت کاربر میشود.
            \item ﺩﺭ ﺍﯾﻦ ﺳﻨﺎﺭﯾﻮ، ﭼﻪ ﺭﻭﺵ ﻫﺎﯾﯽ ﺑﺮﺍﯼ ﺟﻠﻮﮔﯿﺮﯼ ﺍﺯ
            \LR{Context Switching}
            ﻏﯿﺮﺿﺮﻭﺭﯼ ﻭ ﺑﻬﯿﻨﻪ ﺳﺎﺯﯼ ﺯﻣﺎﻥ ﺑﻨﺪﯼ ﻧﺦ ﻫﺎ ﻭﺟﻮﺩ ﺩﺍﺭﺩ؟
            \\
            در این سناریو باید از مکانیزم‌هایی استفاده کنیم که همگام‌سازی این نخ‌ها را به ارمغان می‌آورند.
            در این مکانیزم‌ها تا زمانی که داده‌ها برای پردازش به اندازه کافی نباشند، نخ پردازشی اجرا نمی‌شود
            و یا تا زمانی که چیزی پردازش نشده است، نخ ذخیره سازی اجرا نمی‌شود.
            اگر این مکانیزم‌ها را به علاوه اینکه برای هر نخ زمان اجرای مناسبی را در هر زمانی بین \lr{Context Switch}
            در نظر بگیریم، می‌تواند از \lr{Context Switch}
            های غیر ضروری جلوگیری کنیم و زمان اجرای برنامه را بهینه کنیم.
            \item ﺍﮔﺮ ﺑﺮﻧﺎﻣﻪ ﺷﻤﺎ ﺭﻭﯼ ﯾﮏ ﺳﯿﺴﺘﻢ ﭼﻨﺪ ﻫﺴﺘﻪ ﺍﯼ ﺍﺟﺮﺍ ﺷﻮﺩ، ﭼﻪ ﺗﻔﺎﻭﺕ ﻫﺎﯾﯽ ﺩﺭ ﻧﺤﻮﻩ ﺯﻣﺎﻥ ﺑﻨﺪﯼ ﻧﺦ ﻫﺎ ﻭﺟﻮﺩ ﺧﻮﺍﻫﺪ ﺩﺍﺷﺖ؟
            ﭼﮕﻮﻧﻪ ﻣﯽ ﺗﻮﺍﻥ ﺍﺯ ﻫﺴﺘﻪ ﻫﺎ ﺑﻪ ﻃﻮﺭ ﺑﻬﯿﻨﻪ ﺍﺳﺘﻔﺎﺩﻩ ﮐﺮﺩ؟
            \\
            چون برنامه رو یک سیستم چند هسته‌ای اجرا میشود دیگر احتیاج نداریم که بین نخ‌ها جابه‌جا شود اما همچنان
            به مکانیزم‌های همگام‌سازی نیاز داریم تا بتوانیم نخ‌ها را به صورت همزمان اجرا کنیم.

        \end{enumerate}
    \item ﺑﺮﺭﺳﯽ ﮐﻨﯿﺪ ﺁﯾﺎ ﻣﻤﮑﻦ ﺍﺳﺖ ﮐﻪ ﻓﺮﺁﯾﻨﺪﯼ ﺩﺭ ﯾﮏ ﺑﺎﺯﻩ ﺯﻣﺎﻧﯽ ﯾﺘﯿﻢ ﻭ ﺳﭙﺲ ﺩﺭ ﺑﺎﺯﻩ ﺍﯼ ﺩﯾﮕﺮ ﺗﺒﺪﯾﻞ ﺑﻪ ﻓﺮﺁﯾﻨﺪ ﺯﺍﻣﺒﯽ ﺷﻮﺩ؟
    ﺑﺮﻋﮑﺲ ﺍﯾﻦ ﺳﻨﺎﺭﯾﻮ ﻣﺤﺘﻤﻞ ﺍﺳﺖ؟
    (ﺗﺸﺮﯾﺢ ﮐﻨﯿﺪ ﻭ ﻣﺜﺎﻝ ﺑﺰﻧﯿﺪ)
    \\
    بله این اتفاق ممکن است بیفتد برای مثال فرآیندی را درنظر بگیرید که 
    terminate شده است
    درحالی که فرزندش هنوز اجرا می‌شود،
    این فرزند یتیم شده است و پس از اتمام اجرا ممکن است فرآیند دیگری که در مدیریت این فرآیند را برعهده گرفته است
    در حالت مسدود باشد و فرآیند فرزند تبدیل به زامبی شود.
    \\
    برعکس این اتفاق ممکن نیست چرا که فرآیند زامبی، فرآیندی است که اجرای آن به اتمام رسیده است
    ولی فرآیند پدر هنوز به آن رسیدگی نکرده است پس حتی اگر پدر این فرآیند نیز
    terminate شود،
    سیستم‌عامل به فرآیند فرزند رسیدگی و آن را از لیست فرآیندها حذف می‌کند.
\end{enumerate}
\end{document}